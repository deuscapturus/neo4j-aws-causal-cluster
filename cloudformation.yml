AWSTemplateFormatVersion: "2010-09-09"
Metadata: 
  AWS::CloudFormation::Interface: 
    ParameterGroups: 
      - Label: { default: "Neo4J License" }
        Parameters: [AcceptLicense]
      - Label: { default: "Global configurations" }
        Parameters: [VpcId, KeyName, ECSAMI, NodeSecurityGroups, SNSTopicArn]
      - Label: { default: "Core Nodes Configuration" }
        Parameters: [ClusterInstanceType, SubnetID, DesiredCapacity, EBSSize, EBSType, SpotCoreNodes]
      - Label: { default: "Read replicas configuration" }
        Parameters: [ReplicasInstanceType, ReplicasCount, ReplicasSubnetID, SpotReplicaNodes]
      - Label: { default: "Docker image configurations" }
        Parameters: [DockerImage, DockerECRARN]
      - Label: { default: "Neo4j users configuration" }
        Parameters: [AdminUser, AdminPassword, ReadOnlyUser, ReadOnlyUserPassword]
      - Label: { default: "Cloud Map discovery settings" }
        Parameters: [CloudMapNamespaceID, CloudMapNamespaceName, Neo4jCoreSubdomain, Neo4jReplicasSubdomain]
      - Label: { default: "Neo4J operations" }
        Parameters: [BackupPath, BackupHourlyStoreForDays,BackupDailyStoreForDays, AllowUpgrade, IsDrainSupported, SlowQueryLog]
    ParameterLabels: 
      AcceptLicense: { default: "Do you agree?" }
      IsDrainSupported: { default: "Does your AWS account has system for automatic ECS instance draining deployed?"}
Parameters:
  KeyName:
    Type: AWS::EC2::KeyPair::KeyName
    Description: Name of an existing EC2 KeyPair to enable SSH access to the ECS instances.
  ECSAMI:
    Description: AMI ID
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ecs/optimized-ami/amazon-linux-2/recommended/image_id
  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: Select a VPC that allows instances access to the Internet.
  SubnetID:
    Type: List<AWS::EC2::Subnet::Id>
    Description: Select at two subnets in your selected VPC.
  # RexRay plugin can't work with many volumes with the same name in the same AZ at the same time
  # see issue: https://github.com/rexray/rexray/issues/1314
  ReplicasSubnetID:
    Type: List<AWS::EC2::Subnet::Id>
    Description: Subnets to place the Replicas in
  ReplicasCount:
    Type: Number
    Default: 0
    Description: "If set to 0, all other replica realted settings can be ignored"
  NodeSecurityGroups:
    Type: List<AWS::EC2::SecurityGroup::Id>
    Description: Select at least one additional security group to apply to Neo4j nodes (e.g. your SSH group)
  DesiredCapacity:
    Type: Number
    Default: "3"
    AllowedValues: ["3", "5", "7"]
    Description: Number of instances to launch in your ECS cluster.
  EBSSize:
    Description: Size in GiBs of data volumes to be created for Neo4j nodes.
    Type: Number
    Default: "10"
  EBSType:
    Description: Type of data volumes to be created for Neo4j nodes.
    Type: String
    AllowedValues: [standard, io1, gp2, sc1, st1]
  DockerImage:
    Description: Docker image of Neo4j enterprise, e.g. 111111111111.dkr.ecr.us-east-1.amazonaws.com/neo:c531de3a6655b8c885330ca91b867431760392bf
    Type: String
  DockerECRARN:
    Description: ARN of Docker ECR repository for images, e.g. arn:aws:ecr:us-east-1:111111111111:repository/neo
    Type: String
  AdminUser:
    Description: Username for Neo4j database admin access.
    Type: String
    AllowedValues: [neo4j]
  AdminPassword:
    NoEcho: true
    Description: Password for Neo4j database admin access.
    Type: String
  ReadOnlyUser:
    Description: Username for Neo4j database read-only access.
    Type: String
  ReadOnlyUserPassword:
    NoEcho: true
    Description: Password for Neo4j database read-only access.
    Type: String
  CloudMapNamespaceID:
    Type: String
    Description: |
      If you want to use existing CloudMap Namespace, please provide the ID here.
      Leave empty to create new namespace.
  CloudMapNamespaceName:
    Type: String
    Description: |
      If "CloudMapNamespaceID" were not provided, then new CloudMap will be created.
      The name of the namespace is actually the Route53 private domain that will be used to create dns entry for Neo4J
    Type: String
    Default: neo4j.testing
  Neo4jCoreSubdomain:
    Type: String
    Default: core
    Description: |
      The sudbdomain that well be used for the neo4j core cluster. Will look like
      <subdomain>.<namespace>. For example: core.neo4j.testing
  Neo4jReplicasSubdomain:
    Type: String
    Default: replica
    Description: |
      The sudbdomain that well be used for the neo4j replicas. Will look like
      <subdomain>.<namespace>. For example: replica.neo4j.testing
  BackupPath:
    Description: |
      (FOR RESTORE ONLY) Start cluster from a database backup snapshot (zip). Full S3 path `<bucket_name>/path/to/backup.zip`
      IMPORTNAT: Rolling backup restore is not possible. You need to stop the cluster and then do the import.
      See https://neo4j.com/docs/operations-manual/current/backup/restoring/#backup-restoring-causal-cluster
    Type: String
  ClusterInstanceType:
    Description: EC2 instance type for Neo4J cluster
    Type: String
    Default: t2.medium
    AllowedValues: [ spot.medium, t2.medium, t3.medium, t3a.medium, # 4gb
                     spot.large, t2.large, t3.large, t3a.large, m4.large, m5.large, m5a.large, # 8gb
                     spot.xlarge, t2.xlarge, t3.xlarge, t3a.xlarge, m4.xlarge, m5.xlarge, m5a.xlarge, # 16gb
                     spot.2xlarge, t2.2xlarge, t3.2xlarge, t3a.2xlarge, m4.2xlarge, m5.2xlarge, m5a.2xlarge, # 32gb
                    #  m4.4xlarge, m5.4xlarge, m5a.4xlarge,  # 64gb
                    #  m4.10xlarge, m5.10xlarge, m5a.10xlarge,  # 160gb
                    #  m4.16xlarge, m5.16xlarge, m5a.16xlarge,  # 256gb
                   ] # NOTE: Feel free to extend the list of instances but define Memory maps for them.
    ConstraintDescription: Please choose a valid instance type.
  ReplicasInstanceType:
    Description: EC2 instance type for Neo4J Replicas node
    Type: String
    Default: t2.medium
    AllowedValues: [ spot.medium, t2.medium, t3.medium, t3a.medium, # 4gb
                     spot.large, t2.large, t3.large, t3a.large, m4.large, m5.large, m5a.large, # 8gb
                     spot.xlarge, t2.xlarge, t3.xlarge, t3a.xlarge, m4.xlarge, m5.xlarge, m5a.xlarge, # 16gb
                     spot.2xlarge, t2.2xlarge, t3.2xlarge, t3a.2xlarge, m4.2xlarge, m5.2xlarge, m5a.2xlarge, # 32gb
                    #  m4.4xlarge, m5.4xlarge, m5a.4xlarge,  # 64gb
                    #  m4.10xlarge, m5.10xlarge, m5a.10xlarge,  # 160gb
                    #  m4.16xlarge, m5.16xlarge, m5a.16xlarge,  # 256gb
                   ] # NOTE: Feel free to extend the list of instances but define Memory maps for them.
    ConstraintDescription: Please choose a valid instance type.
  SNSTopicArn:
    Description: SNS topic to send CloudWatch Alarms notifications (if you leave it empty new topic will be created)
    Type: String
  AllowUpgrade:
    Description: Enable this flag to allow upgrading existing data to newer Neo4j version if such is found.
    Type: String
    Default: false
    AllowedValues: [false, true]
  AcceptLicense:
    Description: |
      In order to use Neo4j Enterprise Edition you must accept the license agreement.
      (c) Neo4j Sweden AB.  2019.  All Rights Reserved.
      Use of this Software without a proper commercial license with Neo4j,
      Inc. or its affiliates is prohibited.
      Email inquiries can be directed to: licensing@neo4j.com
      More information is also available at: https://neo4j.com/licensing/
    Type: String
    Default: no
    AllowedValues: [yes, no]
  IsDrainSupported:
    Type: String
    Default: false
    AllowedValues: [false, true]
    Description: |
      For graceful updates automatic drain of ECS Instances needed.
      External tools needed for this, for example: https://github.com/getsocial-rnd/ecs-drain-lambda
      If drain is not supported changes to AutoScaling Group will not be applied automatically.
  SlowQueryLog:
    Type: String
    AllowedValues: [disabled, 0ms, 100ms, 300ms, 500ms, 700ms, 1000ms, 1500ms, 2000ms]
    Default: disabled
    Description: Log all queries slower than ...
  BackupHourlyStoreForDays:
    Type: Number
    Default: 1
    Description: Number of days to store hourly backups
  BackupDailyStoreForDays:
    Type: Number
    Default: 14
    Description: Number of days to store daily backups (backup made at midnight considered as daily)
Mappings:
  InstanceTypes:
    spot.medium: # for testing
      Memory: 4gb
      Instances:
        - InstanceType: t3a.medium
        - InstanceType: t3.medium
        - InstanceType: t2.medium
    spot.large: # for production
      Memory: 8gb
      Instances:
        - InstanceType: t3a.large
        - InstanceType: t3.large
        - InstanceType: m5a.large
        - InstanceType: t2.large
        - InstanceType: m5.large
        - InstanceType: m4.large
    spot.xlarge: # for production
      Memory: 16gb
      Instances:
        - InstanceType: t3a.xlarge
        - InstanceType: t3.xlarge
        - InstanceType: m5a.xlarge
        - InstanceType: t2.xlarge
        - InstanceType: m5.xlarge
        - InstanceType: m4.xlarge
        # r5 is also possible to use here, but they have less cpu
        # - InstanceType: r5.xlarge
        # - InstanceType: r5a.xlarge
    spot.2xlarge: # for production
      Memory: 32gb
      Instances:
        - InstanceType: t3a.2xlarge
        - InstanceType: t3.2xlarge
        - InstanceType: m5a.2xlarge
        - InstanceType: t2.2xlarge
        - InstanceType: m5.2xlarge
        - InstanceType: m4.2xlarge
    t3a.medium:  { Instances: [], Memory: 4gb }
    t3.medium:   { Instances: [], Memory: 4gb }
    t2.medium:   { Instances: [], Memory: 4gb }
    t3a.large:   { Instances: [], Memory: 8gb }
    t3.large:    { Instances: [], Memory: 8gb }
    t2.large:    { Instances: [], Memory: 8gb } 
    m5a.large:   { Instances: [], Memory: 8gb }
    m5.large:    { Instances: [], Memory: 8gb }
    m4.large:    { Instances: [], Memory: 8gb }
    t3a.xlarge:  { Instances: [], Memory: 16gb }
    t3.xlarge:   { Instances: [], Memory: 16gb }
    t2.xlarge:   { Instances: [], Memory: 16gb }
    m5a.xlarge:  { Instances: [], Memory: 16gb }
    m5.xlarge:   { Instances: [], Memory: 16gb }
    m4.xlarge:   { Instances: [], Memory: 16gb }
    t3a.2xlarge: { Instances: [], Memory: 32gb }
    t3.2xlarge:  { Instances: [], Memory: 32gb }
    t2.2xlarge:  { Instances: [], Memory: 32gb }
    m5a.2xlarge: { Instances: [], Memory: 32gb }
    m5.2xlarge:  { Instances: [], Memory: 32gb }
    m4.2xlarge:  { Instances: [], Memory: 32gb }
  MemoryMap:
    4gb:
      ContainerMemory: 3700
      JavaHeap: 2000m
      JavaPage: 800m
      ContainerMemoryReplica: 2500
      JavaHeapReplica: 1200m
      JavaPageReplica: 900m
      ContainerMemoryBackup: 1200
      JavaPageBackup: 600m
    8gb:
      ContainerMemory: 7000
      JavaHeap: 3000m
      JavaPage: 3000m
      ContainerMemoryReplica: 5200
      JavaHeapReplica: 2500m
      JavaPageReplica: 2300m
      ContainerMemoryBackup: 2200
      JavaPageBackup: 1100m
    16gb:
      ContainerMemory: 15000
      JavaHeap: 6800m
      JavaPage: 6800m
      ContainerMemoryReplica: 10000
      JavaHeapReplica: 5500m
      JavaPageReplica: 5500m
      ContainerMemoryBackup: 5000
      JavaPageBackup: 2500m
    32gb:
      ContainerMemory: 31000
      JavaHeap: 13500m
      JavaPage: 13500m
      ContainerMemoryReplica: 26000
      JavaHeapReplica: 11500m
      JavaPageReplica: 11500m
      ContainerMemoryBackup: 5000
      JavaPageBackup: 2500m
    64gb:
      ContainerMemory: 63000
      JavaHeap: 28000m
      JavaPage: 28000m
      ContainerMemoryReplica: 50000
      JavaHeapReplica: 23000m
      JavaPageReplica: 23000m
      ContainerMemoryBackup: 12000
      JavaPageBackup: 6000m
    160gb:
      ContainerMemory: 155000
      JavaHeap: 72000m
      JavaPage: 72000m
      ContainerMemoryReplica: 120000
      JavaHeapReplica: 55000m
      JavaPageReplica: 55000m
      ContainerMemoryBackup: 32000
      JavaPageBackup: 16000m
    256gb:
      ContainerMemory: 250000
      JavaHeap: 120000m
      JavaPage: 120000m
      ContainerMemoryReplica: 200000
      JavaHeapReplica: 95000m
      JavaPageReplica: 95000m
      ContainerMemoryBackup: 45000
      JavaPageBackup: 22500m
Conditions:
  ReplicasEnabled: !Not [!Equals [!Ref ReplicasCount, 0]]
  PerformRestore: !Not [!Equals [!Ref BackupPath, ""]]
  CreateSNSTopic: !Equals [!Ref SNSTopicArn, ""]
  SingleMaster: !Equals [!Ref DesiredCapacity, "1"]
  AcceptedLicense: !Equals [!Ref AcceptLicense, "true"]
  CreateCloudMapNamespace: !Equals [!Ref CloudMapNamespaceID, ""]
  SpotCore: !Or [!Equals [!Ref ClusterInstanceType, "spot.medium"], !Equals [!Ref ClusterInstanceType, "spot.large"], !Equals [!Ref ClusterInstanceType, "spot.xlarge"], !Equals [!Ref ClusterInstanceType, "spot.2xlarge"]]
  SpotReplica: !Or [!Equals [!Ref ReplicasInstanceType, "spot.medium"], !Equals [!Ref ReplicasInstanceType, "spot.large"], !Equals [!Ref ReplicasInstanceType, "spot.xlarge"], !Equals [!Ref ReplicasInstanceType, "spot.2xlarge"]] 
  EnableASGHook: !Equals [!Ref IsDrainSupported, "true"]
  EnableReplicaASGHook: !And [ !Condition EnableASGHook, !Condition ReplicasEnabled]  
  SlowQueryLogEnabled: !Not [ !Equals [!Ref SlowQueryLog, "disabled"]]
  SlowQueryLogReplicaEnabled: !And [ !Condition SlowQueryLogEnabled, !Condition ReplicasEnabled]  
Resources:
  Neo4jCluster:
    Type: AWS::ECS::Cluster
  Neo4jReplicas:
    Condition: ReplicasEnabled
    Type: AWS::ECS::Cluster
  Neo4jSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Neo4j Cluster Security Group
      VpcId: !Ref "VpcId"
  #### Start of inbound rules for cluster nodes communications with each other
  Neo4jSecurityGroupHTTPinboundFromCluster:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref "Neo4jSecurityGroup"
      IpProtocol: tcp
      FromPort: "7473"
      ToPort: "7474"
      SourceSecurityGroupId: !Ref "Neo4jSecurityGroup"
      Description: Neo4j HTTP(S) communication between nodes
  Neo4jSecurityGroupBoltInboundFromCluster:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref "Neo4jSecurityGroup"
      IpProtocol: tcp
      FromPort: "7687"
      ToPort: "7687"
      SourceSecurityGroupId: !Ref "Neo4jSecurityGroup"
      Description: Neo4j Bolt communication between nodes
  Neo4jSecurityGroupDiscoveryInboundFromCluster:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref "Neo4jSecurityGroup"
      IpProtocol: tcp
      FromPort: "5000"
      ToPort: "5000"
      SourceSecurityGroupId: !Ref "Neo4jSecurityGroup"
      Description: Neo4j Discovery communication between nodes
  Neo4jSecurityGroupTransactionInboundFromCluster:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref "Neo4jSecurityGroup"
      IpProtocol: tcp
      FromPort: "6000"
      ToPort: "6000"
      SourceSecurityGroupId: !Ref "Neo4jSecurityGroup"
      Description: Neo4j Transactions communication between nodes
  Neo4jSecurityGroupRaftInboundFromCluster:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref "Neo4jSecurityGroup"
      IpProtocol: tcp
      FromPort: "7000"
      ToPort: "7000"
      SourceSecurityGroupId: !Ref "Neo4jSecurityGroup"
      Description: Neo4j Raft communication between nodes
  Neo4jSecurityGroupHTTPinbound:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref "Neo4jSecurityGroup"
      IpProtocol: tcp
      FromPort: "7473"
      ToPort: "7474"
      CidrIp: 0.0.0.0/0
      Description: Neo4j HTTP(S) external access
  Neo4jSecurityGroupBoltInbound:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref "Neo4jSecurityGroup"
      IpProtocol: tcp
      FromPort: "7687"
      ToPort: "7687"
      CidrIp: 0.0.0.0/0
      Description: Neo4j Bolt external access
  CloudwatchLogsGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub ${AWS::StackName}
      RetentionInDays: 14
  CloudwatchSlowQueryLogsGroup:
    Condition: SlowQueryLogEnabled
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub ${AWS::StackName}/slowquery
      RetentionInDays: 14
  Neo4jClusterTask:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Sub "${AWS::StackName}-cluster"
      NetworkMode: host
      Volumes:
        - Name: !Sub ${AWS::StackName}-data
          DockerVolumeConfiguration:
            Scope: shared
            Autoprovision: true
            Driver: rexray/ebs
            DriverOpts:
              volumetype: !Ref EBSType
              size: !Ref EBSSize
      ContainerDefinitions:
        - Name: neo4j
          Essential: "true"
          Image: !Ref "DockerImage"
          MemoryReservation:
            Fn::If:  
            - ReplicasEnabled
            - Fn::FindInMap:
              - MemoryMap
              - Fn::FindInMap:
                - InstanceTypes
                - !Ref "ClusterInstanceType"
                - Memory
              - ContainerMemory
            - Fn::FindInMap:
              - MemoryMap
              - Fn::FindInMap:
                - InstanceTypes
                - !Ref "ClusterInstanceType"
                - Memory
              - ContainerMemoryReplica
          MountPoints:
          - ContainerPath: /neo4j
            SourceVolume: !Sub ${AWS::StackName}-data
            ReadOnly: false
          PortMappings:
            # discovery port
            - ContainerPort: 5000
              HostPort: 5000
            # transaction port
            - ContainerPort: 6000
              HostPort: 6000
            # raft port
            - ContainerPort: 7000
              HostPort: 7000
            # http interface
            - ContainerPort: 7474
              HostPort: 7474
            # https interface
            - ContainerPort: 7473
              HostPort: 7473
            # bolt interface
            - ContainerPort: 7687
              HostPort: 7687
          Environment:
            - Name: CLOUDMAP_SERVICE_ID
              Value: !Ref DiscoveryServiceCoreSRV
            - Name: NEO4J_dbms_import_csv_legacy__quote__escaping
              Value: false
            - Name: NEO4J_causal__clustering_discovery__type
              # Value: SRV         # discovery based on the SRV record created by CloudMap
              # Value: DNS
              Value: LIST
            - Name: NEO4J_causal__clustering_initial__discovery__members
              # Value: !Sub ${DiscoveryServiceCoreSRV.Name}.${CloudMapNamespaceName}:0
              Value: !Sub ${DiscoveryServiceCoreA.Name}.${CloudMapNamespaceName}:5000
            - Name: NEO4J_causal__clustering_minimum__core__cluster__size__at__formation
              Value: !Ref DesiredCapacity
            - Name: NEO4J_causal__clustering_minimum__core__cluster__size__at__runtime
              Value: 2
            - Name: NEO4J_DATA_ROOT
              Value: /neo4j
            - Name: AWS_REGION
              Value: !Ref AWS::Region
            - Name: NEO4J_dbms_allow__upgrade
              Value: !Ref AllowUpgrade
            - Name: NEO4J_dbms_mode
              Value: CORE
            - Name: NEO4J_dbms_memory_heap_max__size
              Value:
                Fn::If:  
                - ReplicasEnabled
                - Fn::FindInMap:
                  - MemoryMap
                  - Fn::FindInMap:
                    - InstanceTypes
                    - !Ref "ClusterInstanceType"
                    - Memory
                  - JavaHeap
                - Fn::FindInMap:
                  - MemoryMap
                  - Fn::FindInMap:
                    - InstanceTypes
                    - !Ref "ClusterInstanceType"
                    - Memory
                  - JavaHeapReplica
            - Name: NEO4J_dbms_memory_heap_initial__size
              Value:
                Fn::If:  
                - ReplicasEnabled
                - Fn::FindInMap:
                  - MemoryMap
                  - Fn::FindInMap:
                    - InstanceTypes
                    - !Ref "ClusterInstanceType"
                    - Memory
                  - JavaHeap
                - Fn::FindInMap:
                  - MemoryMap
                  - Fn::FindInMap:
                    - InstanceTypes
                    - !Ref "ClusterInstanceType"
                    - Memory
                  - JavaHeapReplica
            - Name: NEO4J_dbms_memory_pagecache_size
              Value:
                Fn::If:  
                - ReplicasEnabled
                - Fn::FindInMap:
                  - MemoryMap
                  - Fn::FindInMap:
                    - InstanceTypes
                    - !Ref "ClusterInstanceType"
                    - Memory
                  - JavaPage
                - Fn::FindInMap:
                  - MemoryMap
                  - Fn::FindInMap:
                    - InstanceTypes
                    - !Ref "ClusterInstanceType"
                    - Memory
                  - JavaPageReplica
            - Name: NEO4J_ADMIN_PASSWORD
              Value: !Ref AdminPassword
            - Name: NEO4J_GUEST_AUTH
              Value: !Join ["", [!Ref ReadOnlyUser, "/", !Ref ReadOnlyUserPassword]]
            - Name: SNAPSHOT_PATH
              Value: !Ref BackupPath
            - Name: AWS_BACKUP_BUCKET
              Value: !Ref BackupBucket
            - Name: STACK_NAME
              Value: !Ref AWS::StackName
            - Name: STACK_ID
              Value: !Ref AWS::StackId
            - Name: NEO4J_ACCEPT_LICENSE_AGREEMENT
              Value: !If [AcceptedLicense, "yes", "no"]
            - !If
              - SlowQueryLogEnabled
              - Name: NEO4J_QUERY_LOG
                Value: enabled
              - Name: NEO4J_QUERY_LOG
                Value: disabled 
            - !If
              - SlowQueryLogEnabled
              - Name: NEO4J_dbms_logs_query_threshold
                Value: !Ref SlowQueryLog
              - !Ref AWS::NoValue
          Ulimits:
            - Name: nofile
              HardLimit: 400000
              SoftLimit: 400000
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref 'CloudwatchLogsGroup'
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: !Ref Neo4jCoreSubdomain
          HealthCheck:
            Command: [ CMD-SHELL, "/healthcheck.sh" ] 
            Interval: 15
            Retries: 10
            StartPeriod: 300
            Timeout: 10
        - !If 
          - SlowQueryLogEnabled
          - Name: tail-slowquery-log
            Image: alpine:latest
            MemoryReservation: 100
            Essential: true
            DependsOn:
            - Condition: START
              ContainerName: neo4j
            MountPoints:
            - ContainerPath: /neo4j
              SourceVolume: !Sub ${AWS::StackName}-data
              ReadOnly: true
            Command: [ tail, -Fn, '+1', /neo4j/logs/slow_query.log ]
            StopTimeout: 3 # tail doesn't gracefully exits on SIGTERM, so give it 3 secs to read all the remaining logs and send KILL
            LogConfiguration:
              LogDriver: awslogs
              Options:
                awslogs-group: !Ref 'CloudwatchSlowQueryLogsGroup'
                awslogs-region: !Ref 'AWS::Region'
                awslogs-stream-prefix: !Ref Neo4jCoreSubdomain
                awslogs-multiline-pattern: '^\d{4}-\d{1,2}-\d{1,2} \d{1,2}:\d{1,2}:\d{1,2}' # date like 2019-08-29 13:44:21.146
          - !Ref AWS::NoValue
  Neo4jReplicasTask:
    Condition: ReplicasEnabled
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Sub "${AWS::StackName}-replica"
      NetworkMode: host
      Volumes:
        - Name: exports
          Host:
            SourcePath: "/tmp/exports"
        - Name: data
      ContainerDefinitions:
        - Name: neo4j
          Essential: "true"
          Image: !Ref "DockerImage"
          Memory:
            Fn::FindInMap:
            - MemoryMap
            - Fn::FindInMap:
              - InstanceTypes
              - !Ref "ReplicasInstanceType"
              - Memory
            - "ContainerMemoryReplica"
          MountPoints:
            - ContainerPath: /tmp/exports
              SourceVolume: exports
              ReadOnly: false
            - ContainerPath: /neo4j
              SourceVolume: data
              ReadOnly: false
          PortMappings:
            # discovery port
            - ContainerPort: 5000
              HostPort: 5000
            # transaction port
            - ContainerPort: 6000
              HostPort: 6000
            # raft port
            - ContainerPort: 7000
              HostPort: 7000
            # http interface
            - ContainerPort: 7474
              HostPort: 7474
            # https interface
            - ContainerPort: 7473
              HostPort: 7473
            # bolt interface
            - ContainerPort: 7687
              HostPort: 7687
          Environment:
            - Name: CLOUDMAP_SERVICE_ID
              Value: !Ref DiscoveryServiceCoreSRV
            - Name: NEO4J_causal__clustering_discovery__type
              # Value: SRV         # discovery based on the SRV record created by CloudMap
              Value: LIST
            - Name: NEO4J_causal__clustering_initial__discovery__members
              Value: !Sub ${DiscoveryServiceCoreSRV.Name}.${CloudMapNamespaceName}:0
            - Name: AWS_REGION
              Value: !Ref AWS::Region
            - Name: NEO4J_dbms_allow__upgrade
              Value: !Ref AllowUpgrade
            - Name: NEO4J_dbms_mode
              Value: READ_REPLICA
            - Name: NEO4J_dbms_memory_heap_max__size
              Value:
                Fn::FindInMap:
                - MemoryMap
                - Fn::FindInMap:
                  - InstanceTypes
                  - !Ref "ReplicasInstanceType"
                  - Memory
                - "JavaHeapReplica"
            - Name: NEO4J_dbms_memory_heap_initial__size
              Value:
                Fn::FindInMap:
                - MemoryMap
                - Fn::FindInMap:
                  - InstanceTypes
                  - !Ref "ReplicasInstanceType"
                  - Memory
                - "JavaHeapReplica"
            - Name: NEO4J_dbms_memory_pagecache_size
              Value:
                Fn::FindInMap:
                - MemoryMap
                - Fn::FindInMap:
                  - InstanceTypes
                  - !Ref "ReplicasInstanceType"
                  - Memory
                - "JavaPageReplica"
            - Name: NEO4J_ADMIN_PASSWORD
              Value: !Ref AdminPassword
            - Name: NEO4J_GUEST_AUTH
              Value: !Join ["", [!Ref ReadOnlyUser, "/", !Ref ReadOnlyUserPassword]]
            # Remove read replica snapshot restoration because of the problem
            # 2019-09-18 09:07:20.751+0000 ERROR Failed to start Neo4j: Starting Neo4j failed: Component 'org.neo4j.server.database.LifecycleManagingDatabase@7da31a40' 
            # was successfully initialized, but failed to start. Please see the attached cause exception "Timer already cancelled.". 
            # Starting Neo4j failed: Component 'org.neo4j.server.database.LifecycleManagingDatabase@7da31a40' was successfully initialized, 
            # but failed to start. Please see the attached cause exception "Timer already cancelled.".
            # - Name: SNAPSHOT_PATH
            #   Value: !Ref BackupPath
            - Name: AWS_BACKUP_BUCKET
              Value: !Ref BackupBucket
            - Name: STACK_NAME
              Value: !Ref AWS::StackName
            - Name: STACK_ID
              Value: !Ref AWS::StackId
            - Name: NEO4J_ACCEPT_LICENSE_AGREEMENT
              Value: !If [AcceptedLicense, "yes", "no"]
            - Name: NEO4J_DATA_ROOT
              Value: /neo4j
            - !If
              - SlowQueryLogEnabled
              - Name: NEO4J_QUERY_LOG
                Value: enabled
              - Name: NEO4J_QUERY_LOG
                Value: disabled 
            - !If
              - SlowQueryLogEnabled
              - Name: NEO4J_dbms_logs_query_threshold
                Value: !Ref SlowQueryLog
              - !Ref AWS::NoValue
          Ulimits:
            - Name: nofile
              HardLimit: 400000
              SoftLimit: 400000
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref 'CloudwatchLogsGroup'
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: !Ref Neo4jReplicasSubdomain
          HealthCheck:
            Command: [ CMD-SHELL, "/healthcheck.sh" ] 
            Interval: 60
            Retries: 10
            StartPeriod: 300
            Timeout: 10
        - !If 
          - SlowQueryLogReplicaEnabled
          - Name: tail-slowquery-log
            Image: alpine:latest
            MemoryReservation: 100
            Essential: true
            DependsOn:
            - Condition: START
              ContainerName: neo4j
            Command: [ tail, -Fn, '+1', /neo4j/logs/slow_query.log ]
            StopTimeout: 3
            MountPoints:
            - ContainerPath: /neo4j
              SourceVolume: data
              ReadOnly: true
            LogConfiguration:
              LogDriver: awslogs
              Options:
                awslogs-group: !Ref 'CloudwatchSlowQueryLogsGroup'
                awslogs-region: !Ref 'AWS::Region'
                awslogs-stream-prefix: !Ref Neo4jReplicasSubdomain
                awslogs-multiline-pattern: '^\d{4}-\d{1,2}-\d{1,2} \d{1,2}:\d{1,2}:\d{1,2}' # date like 2019-08-29 13:44:21.146
          - !Ref AWS::NoValue
  DiscoveryNamespace:
    Condition: CreateCloudMapNamespace
    Type: AWS::ServiceDiscovery::PrivateDnsNamespace
    Properties: 
      Description: Neo4J CloudMap discovery service
      Name: !Ref CloudMapNamespaceName
      Vpc: !Ref VpcId
  DiscoveryServiceCoreSRV:
    Type: 'AWS::ServiceDiscovery::Service'
    Properties:
      Description: CloudMap DNS based discovery for Neo4J
      DnsConfig:
        DnsRecords:
          - Type: SRV
            TTL: 10
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: !Sub discovery.${Neo4jCoreSubdomain}
      NamespaceId: !If [CreateCloudMapNamespace, !Ref DiscoveryNamespace, !Ref CloudMapNamespaceID]
  DiscoveryServiceCoreA:
    Type: 'AWS::ServiceDiscovery::Service'
    Properties:
      Description: CloudMap DNS based discovery for Neo4J
      DnsConfig:
        DnsRecords: 
          - Type: A
            TTL: 10
        RoutingPolicy: MULTIVALUE
      Name: !Ref Neo4jCoreSubdomain 
      NamespaceId: !If [CreateCloudMapNamespace, !Ref DiscoveryNamespace, !Ref CloudMapNamespaceID]
  DiscoveryServiceReplicaA:
    Condition: ReplicasEnabled
    Type: 'AWS::ServiceDiscovery::Service'
    Properties:
      Description: CloudMap DNS based discovery for Neo4J
      DnsConfig:
        DnsRecords:
          - Type: A
            TTL: 10
        RoutingPolicy: MULTIVALUE
      Name: !Ref Neo4jReplicasSubdomain
      NamespaceId: !If [CreateCloudMapNamespace, !Ref DiscoveryNamespace, !Ref CloudMapNamespaceID]
  DiscoveryServiceReplicaSRV:
    Condition: ReplicasEnabled
    Type: 'AWS::ServiceDiscovery::Service'
    Properties:
      Description: CloudMap DNS based discovery for Neo4J
      DnsConfig:
        DnsRecords:
          - Type: SRV
            TTL: 10
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: !Sub discovery.${Neo4jReplicasSubdomain}
      NamespaceId: !If [CreateCloudMapNamespace, !Ref DiscoveryNamespace, !Ref CloudMapNamespaceID]
  Neo4jClusterAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier: !Ref 'SubnetID'
      MinSize: "2"
      MaxSize: !Ref "DesiredCapacity"
      DesiredCapacity: !Ref "DesiredCapacity"
      LaunchTemplate: !If
        - SpotCore
        - !Ref AWS::NoValue
        - Version: !GetAtt Neo4jClusterLanuchTemplate.LatestVersionNumber
          LaunchTemplateId: !Ref Neo4jClusterLanuchTemplate
      MixedInstancesPolicy: !If
        - SpotCore
        - 
          LaunchTemplate:
            LaunchTemplateSpecification:
              Version: !GetAtt Neo4jClusterLanuchTemplate.LatestVersionNumber
              LaunchTemplateId: !Ref Neo4jClusterLanuchTemplate
            Overrides: !FindInMap [ InstanceTypes, !Ref  ClusterInstanceType, Instances]
          InstancesDistribution:
            OnDemandAllocationStrategy: prioritized
            OnDemandBaseCapacity: 0
            OnDemandPercentageAboveBaseCapacity: 0 # all spot instances
            SpotAllocationStrategy: lowest-price
            # SpotInstancePools ensures the HA of spot instances
            # basically this dictates the number of instances with different
            # spot prices to be launched, to ensure the least impact
            # on your instances in case of price change.
            # Each instance type in each AZ is a valid pool
            # so maximum number of pools is `number of instances types * number of az`
            # basically 4 instances types in 4 AZ makes 16 different pools
            SpotInstancePools: !Ref "DesiredCapacity"
            # SpotMaxPrices sets the maximum price you are willing to pay for the instance
            # setting the null value (AWS::NoValue) ensures the MaxPrice is the same
            # as actuall on demand price for that instance type.
            # If you change this value, it can't be changed back :(
            SpotMaxPrice: !Ref AWS::NoValue
        - !Ref AWS::NoValue
      Tags:
        - Key: App
          Value: Neo4j
          PropagateAtLaunch: true
        - Key: NEO4J_MODE
          Value: CORE
          PropagateAtLaunch: true
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    UpdatePolicy: !If 
      - EnableASGHook 
      - AutoScalingRollingUpdate:
          MaxBatchSize: 1
          MinInstancesInService: 2
          PauseTime: PT10M
          WaitOnResourceSignals: True
      - AutoScalingRollingUpdate: !Ref AWS::NoValue 
  CoreASGTerminateHook:
    Condition: EnableASGHook
    Type: "AWS::AutoScaling::LifecycleHook"
    Properties:
      AutoScalingGroupName: !Ref Neo4jClusterAutoScalingGroup
      DefaultResult: "ABANDON"
      HeartbeatTimeout: 3600
      LifecycleTransition: "autoscaling:EC2_INSTANCE_TERMINATING"
  Neo4jReplicasAutoScalingGroup:
    Condition: ReplicasEnabled
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier: !Ref "ReplicasSubnetID"
      MinSize: "1"
      MaxSize: !Ref ReplicasCount
      DesiredCapacity: !Ref ReplicasCount
      LaunchTemplate: !If
        - SpotReplica
        - !Ref AWS::NoValue
        - Version: !GetAtt Neo4jReplicasLanuchTemplate.LatestVersionNumber
          LaunchTemplateId: !Ref Neo4jReplicasLanuchTemplate
      MixedInstancesPolicy: !If
        - SpotReplica
        -
          LaunchTemplate:
            LaunchTemplateSpecification:
              Version: !GetAtt Neo4jReplicasLanuchTemplate.LatestVersionNumber
              LaunchTemplateId: !Ref Neo4jReplicasLanuchTemplate
            Overrides: !FindInMap [ InstanceTypes, !Ref ReplicasInstanceType, Instances ] 
          InstancesDistribution:
            OnDemandAllocationStrategy: prioritized
            OnDemandBaseCapacity: 0
            OnDemandPercentageAboveBaseCapacity: 0 # all spot instances
            SpotAllocationStrategy: lowest-price
            SpotInstancePools: !Ref "ReplicasCount"
            SpotMaxPrice: !Ref AWS::NoValue
        - !Ref AWS::NoValue
      Tags:
        - Key: App
          Value: Neo4j
          PropagateAtLaunch: true
        - Key: Cluster
          Value: "false"
          PropagateAtLaunch: true
        - Key: NEO4J_MODE
          Value: READ_REPLICA
          PropagateAtLaunch: true
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    UpdatePolicy: !If 
      - EnableReplicaASGHook 
      - AutoScalingRollingUpdate:
          MaxBatchSize: 1
          MinInstancesInService: 0
          PauseTime: PT10M
          WaitOnResourceSignals: True
      - AutoScalingRollingUpdate: !Ref AWS::NoValue 
  ReplicaASGTerminateHook:
    Condition: EnableReplicaASGHook
    Type: "AWS::AutoScaling::LifecycleHook"
    Properties:
      AutoScalingGroupName: !Ref Neo4jReplicasAutoScalingGroup
      DefaultResult: "ABANDON"
      HeartbeatTimeout: 3600
      LifecycleTransition: "autoscaling:EC2_INSTANCE_TERMINATING"
  Neo4jClusterLanuchTemplate:
    Type: "AWS::EC2::LaunchTemplate"
    Properties:
      LaunchTemplateData:
        SecurityGroupIds: !Split      # this hack is made to append to the list :/
        - ","
        - !Sub
          - "${idList},${Neo4jSecurityGroup}"
          - idList: !Join [",", !Ref "NodeSecurityGroups"]
        UserData:
          Fn::Base64: !Sub |
            #cloud-config
            packages:
            - aws-cfn-bootstrap
            - jq
            - htop
            - vim
            - amazon-ssm-agent
            write_files:
              - path: /etc/ecs/ecs.config
                append: true
                content: |
                  ECS_CLUSTER=${Neo4jCluster}
                  ECS_CONTAINER_STOP_TIMEOUT=2m
              - path: /etc/security/limits.conf
                content: |
                  *               soft    nofile  400000
                  *               hard    nofile  400000
                  root            soft    nofile  400000
                  root            hard    nofile  400000
            runcmd:
              - [ systemctl, enable, amazon-ssm-agent ]
              - [ systemctl, start,  amazon-ssm-agent ]
              - [ docker, plugin, install, rexray/ebs, --grant-all-permissions, LINUX_VOLUME_ROOTPATH=/, LIBSTORAGE_INTEGRATION_VOLUME_OPERATIONS_MOUNT_ROOTPATH=/ ]
              - /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource Neo4jClusterAutoScalingGroup --region ${AWS::Region}
        BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            DeleteOnTermination: true
            VolumeSize: 30
            VolumeType: gp2
        IamInstanceProfile:
          Name: !Ref Neo4jInstanceProfile
        KeyName: !Ref 'KeyName'
        ImageId: !Ref ECSAMI
        InstanceType: !Ref 'ClusterInstanceType'
        Monitoring:
          Enabled: true
  Neo4jReplicasLanuchTemplate:
    Condition: ReplicasEnabled
    Type: "AWS::EC2::LaunchTemplate"
    Properties:
      LaunchTemplateData:
        SecurityGroupIds: !Split      # this hack is made to append to the list :/
        - ","
        - !Sub
          - "${idList},${Neo4jSecurityGroup}"
          - idList: !Join [",", !Ref "NodeSecurityGroups"]
        UserData:
          Fn::Base64: !Sub |
            #cloud-config
            packages:
            - aws-cfn-bootstrap
            - jq
            - htop
            - vim
            - amazon-ssm-agent
            write_files:
              - path: /etc/ecs/ecs.config
                append: true
                content: |
                  ECS_CLUSTER=${Neo4jReplicas}
                  ECS_CONTAINER_STOP_TIMEOUT=2m
              - path: /etc/security/limits.conf
                content: |
                  *               soft    nofile  400000
                  *               hard    nofile  400000
                  root            soft    nofile  400000
                  root            hard    nofile  400000
            runcmd:
              - [ systemctl, enable, amazon-ssm-agent ]
              - [ systemctl, start,  amazon-ssm-agent ]
              - [ docker, plugin, install, rexray/ebs, --grant-all-permissions, LINUX_VOLUME_ROOTPATH=/, LIBSTORAGE_INTEGRATION_VOLUME_OPERATIONS_MOUNT_ROOTPATH=/ ]
              - /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource Neo4jReplicasAutoScalingGroup --region ${AWS::Region}
        BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            DeleteOnTermination: true
            VolumeSize: 30
            VolumeType: gp2
        IamInstanceProfile:
          Name: !Ref Neo4jInstanceProfile
        KeyName: !Ref 'KeyName'
        ImageId: !Ref ECSAMI
        InstanceType: !Ref 'ReplicasInstanceType'
        Monitoring:
          Enabled: true
  Neo4jClusterECSservice:
    Type: AWS::ECS::Service
    Properties:
      Cluster: !Ref "Neo4jCluster"
      DesiredCount: !Ref "DesiredCapacity"
      DeploymentConfiguration:
        MinimumHealthyPercent: !If [SingleMaster, "0", "50"]
        MaximumPercent: "100"
      TaskDefinition: !Ref "Neo4jClusterTask"
      PlacementConstraints: [ Type: distinctInstance ] ## aka OneTaskPerHost
      PlacementStrategies:
      - Type: spread
        Field: attribute:ecs.availability-zone
      - Type: spread
        Field: instanceId
      ServiceRegistries:
        - RegistryArn: !GetAtt DiscoveryServiceCoreSRV.Arn
          ContainerName: neo4j
          ContainerPort: 5000
  Neo4jReplicasECSservice:
    Condition: ReplicasEnabled
    Type: AWS::ECS::Service
    DependsOn: Neo4jClusterECSservice
    Properties:
      Cluster: !Ref "Neo4jReplicas"
      DesiredCount: !Ref ReplicasCount
      DeploymentConfiguration:
        MinimumHealthyPercent: "0"
        MaximumPercent: "100"
      TaskDefinition: !Ref "Neo4jReplicasTask"
      PlacementConstraints: [ Type: distinctInstance ] ## aka OneTaskPerHost
      PlacementStrategies:
      - Type: spread
        Field: attribute:ecs.availability-zone
      - Type: spread
        Field: instanceId
      ServiceRegistries:
        - RegistryArn: !GetAtt DiscoveryServiceReplicaSRV.Arn
          ContainerName: neo4j
          ContainerPort: 5000
  S3RestorePolicy:
    Condition: PerformRestore
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: !Sub "${AWS::StackName}-s3-restore-access"
      PolicyDocument:
        Statement:
          - Effect: Allow
            Action:
              - "s3:GetObject"
            Resource: !Sub "arn:aws:s3:::${BackupPath}"
      Roles:
        - Ref: "EC2Role"
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ec2.amazonaws.com]
            Action: ["sts:AssumeRole"]
      Path: /
      Policies:
        - PolicyName: ecs-service
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - "ecs:CreateCluster"
                  - "ecs:DeregisterContainerInstance"
                  - "ecs:DiscoverPollEndpoint"
                  - "ecs:Poll"
                  - "ecs:RegisterContainerInstance"
                  - "ecs:StartTelemetrySession"
                  - "ecs:Submit*"
                  - "ecs:StartTask"
                  - "ecs:StopTask"
                  - "ecs:UpdateContainerInstancesState"
                  - "ecs:UpdateService"
                  - "autoscaling:Describe*"
                  - "ecr:GetAuthorizationToken"
                  - "servicediscovery:ListInstances"
                Resource: "*"
              - Effect: Allow
                Action:
                  - "ecr:GetDownloadUrlForLayer"
                  - "ecr:BatchGetImage"
                  - "ecr:BatchCheckLayerAvailability"
                Resource: !Ref DockerECRARN
        - PolicyName: s3-backup-access
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - "s3:ListBucket"
                Resource: !GetAtt BackupBucket.Arn
              - Effect: Allow
                Action:
                  - "s3:PutObject"
                  - "s3:GetObject"
                Resource: !Sub "${BackupBucket.Arn}/*"
        - PolicyName: rexray-ebs
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - ec2:CreateVolume
                  - ec2:AttachVolume
                  - ec2:CreateSnapshot
                  - ec2:CreateTags
                  - ec2:DeleteVolume
                  - ec2:DeleteSnapshot
                  - ec2:DescribeAvailabilityZones
                  - ec2:DescribeInstances
                  - ec2:DescribeVolumes
                  - ec2:DescribeVolumeAttribute
                  - ec2:DescribeVolumeStatus
                  - ec2:DescribeSnapshots
                  - ec2:CopySnapshot
                  - ec2:DescribeSnapshotAttribute
                  - ec2:DetachVolume
                  - ec2:ModifySnapshotAttribute
                  - ec2:ModifyVolumeAttribute
                  - ec2:DescribeTags
                Resource: "*"
        - PolicyName: cloudwatch-logs
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action: 
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                  - "logs:DescribeLogStreams"
                Resource: 
                  - !GetAtt CloudwatchLogsGroup.Arn
                  - !If [SlowQueryLogEnabled, !GetAtt CloudwatchSlowQueryLogsGroup.Arn, !Ref "AWS::NoValue"]
  Neo4jInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles: [!Ref "EC2Role"]
  Neo4jBackupTask:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Sub "${AWS::StackName}-cluster-backup"
      Volumes:
        - Name: backups
          Host:
            SourcePath: "/opt/backups/"
      ContainerDefinitions:
        - Name: neo4j-backup
          Command: [ backup ]
          Essential: "true"
          Image: !Ref "DockerImage"
          Memory:
            Fn::FindInMap:
            - MemoryMap
            - Fn::FindInMap:
              - InstanceTypes
              - !Ref "ClusterInstanceType"
              - Memory
            - "ContainerMemoryBackup"
          MountPoints:
            - ContainerPath: /tmp
              SourceVolume: backups
              ReadOnly: false
          Environment:
            - Name: NEO4J_dbms_memory_pagecache_size
              Value:
                Fn::FindInMap:
                - MemoryMap
                - Fn::FindInMap:
                  - InstanceTypes
                  - !Ref "ClusterInstanceType"
                  - Memory
                - "JavaPageBackup"
            - Name: BACKUP_DIR
              Value: "/tmp"
            - Name: BACKUP_FROM
              Value: this_instance
            - Name: AWS_BACKUP_BUCKET
              Value: !Ref BackupBucket
            - Name: NEO4J_ACCEPT_LICENSE_AGREEMENT
              Value: !If [AcceptedLicense, "yes", "no"]
          Ulimits:
            - Name: nofile
              HardLimit: 400000
              SoftLimit: 400000
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref 'CloudwatchLogsGroup'
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: backup
  BackupBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Retain
    Properties:
      BucketName: !Sub "${AWS::StackName}-cluster-backup"
      AccessControl: Private
      LifecycleConfiguration:
        Rules:
          - ExpirationInDays: !Ref BackupHourlyStoreForDays
            Id: !Sub "hourly-snapshots-expiration"
            Prefix: hourly/
            Status: Enabled
          - ExpirationInDays: !Ref BackupDailyStoreForDays
            Id: !Sub "daily-snapshots-expiration"
            Prefix: daily/
            Status: Enabled
  BackupEventRule:
    Type: "AWS::Events::Rule"
    Properties:
      Description: "Schedule to run Neo4j-cluster backups"
      Name: !Sub "${AWS::StackName}-backup"
      ScheduleExpression: rate(1 hour)
      State: ENABLED
      Targets:
        - Arn: !If ["ReplicasEnabled", !GetAtt Neo4jReplicas.Arn, !GetAtt Neo4jCluster.Arn ] 
          Id: !Sub "${AWS::StackName}-backup-cluster"
          EcsParameters:
            TaskCount: 1
            TaskDefinitionArn: !Ref Neo4jBackupTask
          RoleArn: !GetAtt BackupEventRole.Arn
  BackupEventRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [events.amazonaws.com]
            Action: ["sts:AssumeRole"]
      Path: /
      Policies:
        - PolicyName: event-run-task
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - "ecs:RunTask"
                Resource: !Ref Neo4jBackupTask
  Neo4jSNSTopic:
    Type: AWS::SNS::Topic
    Condition: CreateSNSTopic
  Neo4jClusterHighMemory:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub "${AWS::StackName}-high-mem"
      AlarmDescription: !Sub "${AWS::StackName} HIGH ECS Memory Utilization."
      Namespace: AWS/ECS
      MetricName: MemoryUtilization
      Dimensions:
        - Name: ClusterName
          Value: !Ref Neo4jCluster
      Statistic: Average
      Period: 60
      EvaluationPeriods: 3
      Threshold: 70
      ComparisonOperator: GreaterThanThreshold
      AlarmActions:
        - !If [CreateSNSTopic, !Ref Neo4jSNSTopic, !Ref SNSTopicArn]
  Neo4jClusterHighCPU:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub "${AWS::StackName}-high-cpu"
      AlarmDescription: !Sub "${AWS::StackName} HIGH ECS CPU Utilization."
      Namespace: AWS/ECS
      MetricName: CPUUtilization
      Dimensions:
        - Name: ClusterName
          Value: !Ref Neo4jCluster
      Statistic: Average
      Period: 60
      EvaluationPeriods: 3
      Threshold: 70
      ComparisonOperator: GreaterThanThreshold
      AlarmActions:
        - !If [CreateSNSTopic, !Ref Neo4jSNSTopic, !Ref SNSTopicArn]
  Neo4jReplicasHighMemory:
    Condition: ReplicasEnabled
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub "${AWS::StackName}-replica-high-mem"
      AlarmDescription: !Sub "${AWS::StackName} HIGH ECS Memory Utilization."
      Namespace: AWS/ECS
      MetricName: MemoryUtilization
      Dimensions:
        - Name: ClusterName
          Value: !Ref Neo4jReplicas
      Statistic: Average
      Period: 60
      EvaluationPeriods: 10
      Threshold: 70
      ComparisonOperator: GreaterThanThreshold
      AlarmActions:
        - !If [CreateSNSTopic, !Ref Neo4jSNSTopic, !Ref SNSTopicArn]
  Neo4jReplicasHighCPU:
    Condition: ReplicasEnabled
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub "${AWS::StackName}-replica-high-cpu"
      AlarmDescription: !Sub "${AWS::StackName} HIGH ECS CPU Utilization."
      Namespace: AWS/ECS
      MetricName: CPUUtilization
      Dimensions:
        - Name: ClusterName
          Value: !Ref Neo4jReplicas
      Statistic: Average
      Period: 60
      EvaluationPeriods: 10
      Threshold: 70
      ComparisonOperator: GreaterThanThreshold
      AlarmActions:
        - !If [CreateSNSTopic, !Ref Neo4jSNSTopic, !Ref SNSTopicArn]
  Neo4jRunningCoresAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub "${AWS::StackName}-running-neo4j-cores-count" 
      AlarmDescription: !Sub "${AWS::StackName} running not enough Neo4j core nodes to sustain the cluster"
      Namespace: ECS/ContainerInsights
      MetricName: RunningTaskCount
      Dimensions:
      - Name: ServiceName
        Value: !GetAtt Neo4jClusterECSservice.Name
      - Name: ClusterName
        Value: !Ref Neo4jCluster
      Statistic: Minimum
      Period: 60
      EvaluationPeriods: 2
      Threshold: 2 # same as NEO4J_causal__clustering_minimum__core__cluster__size__at__runtime
      ComparisonOperator: LessThanThreshold 
      AlarmActions:
        - !If [CreateSNSTopic, !Ref Neo4jSNSTopic, !Ref SNSTopicArn]
  Neo4jRunningReplicasAlarm:
    Condition: ReplicasEnabled
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub "${AWS::StackName}-running-neo4j-replicas-count" 
      AlarmDescription: !Sub "${AWS::StackName} number of running  Neo4j replica nodes are smaller than desired"
      Namespace: ECS/ContainerInsights
      MetricName: RunningTaskCount
      Dimensions:
      - Name: ServiceName
        Value: !GetAtt Neo4jReplicasECSservice.Name
      - Name: ClusterName
        Value: !Ref Neo4jReplicas
      Statistic: Minimum
      Period: 60
      EvaluationPeriods: 2
      Threshold: !Ref ReplicasCount # same as NEO4J_causal__clustering_minimum__core__cluster__size__at__runtime
      ComparisonOperator: LessThanThreshold 
      AlarmActions:
        - !If [CreateSNSTopic, !Ref Neo4jSNSTopic, !Ref SNSTopicArn]
  CloudMapSyncFuncRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
            - sts:AssumeRole
            Effect: Allow
            Principal:
              Service: [lambda.amazonaws.com]
      Policies:
        - PolicyName: cloudwatch-logs-acess
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogStream'
                Resource: !GetAtt LambdaLogGroup.Arn 
              - Effect: Allow
                Action:
                  - 'logs:PutLogEvents'
                Resource: !Sub ${LambdaLogGroup.Arn}:*
        - PolicyName: lambda-service-discovery-access
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - "servicediscovery:GetOperation"
                  - "servicediscovery:DiscoverInstances"
                  - "servicediscovery:GetInstancesHealthStatus"
                  - "servicediscovery:GetInstance" 
                  - "servicediscovery:ListInstances"
                Resource: "*"
              - Effect: Allow
                Action:
                  - "servicediscovery:DeregisterInstance"
                  - "servicediscovery:RegisterInstance"
                  - "route53:ChangeResourceRecordSets"
                Resource: "*" 
                  # - !GetAtt DiscoveryServiceCoreA.Arn
                  # - !GetAtt DiscoveryServiceReplicaA.Arn
  LambdaLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Properties:
      LogGroupName: !Sub /aws/lambda/${AWS::StackName}-cloud-map-sync
  CloudMapSyncFunction:
    DependsOn: [Neo4jClusterTask]
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-cloud-map-sync 
      Description: Function to create A records from SRV records by AWS CloudMap
      Handler: index.lambda_handler
      Runtime: python3.6
      Role: !GetAtt CloudMapSyncFuncRole.Arn
      MemorySize: 128
      Timeout: 10
      Environment:
        Variables: 
          CLOUDMAP_NAMESPACE: !If [CreateCloudMapNamespace, !Ref DiscoveryNamespace, !Ref CloudMapNamespaceID]
          ECS_CORE_TASK: !Ref Neo4jClusterTask
          ECS_REPLICA_TASK: !If [ReplicasEnabled, !Ref Neo4jReplicasTask, !Ref "AWS::NoValue" ]
          NEO4J_CORE_SERVICE_SRV: !Ref DiscoveryServiceCoreSRV
          NEO4j_CORE_SERVICE_A: !Ref DiscoveryServiceCoreA
          NEO4J_REPLICA_SERVICE_SRV: !If [ ReplicasEnabled, !Ref DiscoveryServiceReplicaSRV, !Ref "AWS::NoValue" ] 
          NEO4j_REPLICA_SERVICE_A: !If [ ReplicasEnabled, !Ref DiscoveryServiceReplicaA, !Ref "AWS::NoValue" ] 
      Code:
        ZipFile: |
          import boto3
          import os
          import uuid

          def cloudmap_sync(namespace, srv_service, a_service):
              cmap = boto3.client('servicediscovery')
              srv_instances = cmap.list_instances(
                  ServiceId=srv_service, MaxResults=100)

              a_instances = cmap.list_instances(
                  ServiceId=a_service, MaxResults=100)

              instances_to_deregister = []
              operations_to_check = []

              # check if instance is present in the list of
              # discovery_instances, which is managed by ECS
              for a_inst in a_instances['Instances']:
                  is_present = False
                  for srv_inst in srv_instances['Instances']:
                      if a_inst['Id'] == srv_inst['Id']:
                          is_present = True
                          break

                  if not is_present:
                      instances_to_deregister.append(a_inst['Id'])

              for i in instances_to_deregister:
                  resp = cmap.deregister_instance(
                      ServiceId=a_service, InstanceId=i)

                  operations_to_check.append(resp['OperationId'])

              for instance in srv_instances['Instances']:
                  resp = cmap.register_instance(
                      ServiceId=a_service,
                      InstanceId=instance['Id'],
                      CreatorRequestId=str(uuid.uuid4()),
                      Attributes=instance['Attributes']
                  )
                  operations_to_check.append(resp['OperationId'])

              while operations_to_check:
                  operation = operations_to_check.pop(0)
                  resp = cmap.get_operation(OperationId=operation)["Operation"]
                  if resp["Status"] == "SUCCESS":
                      print("Successful operation '{}' of type '{}' for targets '{}'".format(
                          resp["Id"], resp["Type"], resp["Targets"]))
                  elif resp["Status"] == "FAIL":
                      print("FAILED OPERATION '{}' of type '{}' for targets '{}'\nError Code: '{}'\nErrorMessage: '{}'".format(
                          resp["Id"], resp["Type"], resp["Targets"], resp["ErrorCode"], resp["ErrorMessage"]))
                  else:
                      operations_to_check.append(operation)

          def lambda_handler(event, context):
              CLOUDMAP_NAMESPACE = os.environ.get("CLOUDMAP_NAMESPACE")
              ECS_CORE_TASK = os.environ.get("ECS_CORE_TASK")
              ECS_REPLICA_TASK = os.environ.get("ECS_REPLICA_TASK")
              NEO4J_CORE_SERVICE_SRV = os.environ.get("NEO4J_CORE_SERVICE_SRV")
              NEO4j_CORE_SERVICE_A = os.environ.get("NEO4j_CORE_SERVICE_A")
              NEO4J_REPLICA_SERVICE_SRV = os.environ.get("NEO4J_REPLICA_SERVICE_SRV")
              NEO4j_REPLICA_SERVICE_A = os.environ.get("NEO4j_REPLICA_SERVICE_A")

              if "detail" not in event:
                  raise Exception("'detail' missing in the event")

              if "taskDefinitionArn" not in event["detail"]:
                  raise Exception("'taskDefinitionArn' missing in the event['detail']")

              if event["detail"]["taskDefinitionArn"] == ECS_CORE_TASK:
                  cloudmap_sync(CLOUDMAP_NAMESPACE, NEO4J_CORE_SERVICE_SRV,
                                NEO4j_CORE_SERVICE_A)
              elif event["detail"]["taskDefinitionArn"] == ECS_REPLICA_TASK:
                  cloudmap_sync(CLOUDMAP_NAMESPACE, NEO4J_REPLICA_SERVICE_SRV,
                                NEO4j_REPLICA_SERVICE_A)
              else:
                  raise Exception("Not known task definition " +
                        event["detail"]["taskDefinitionArn"])
  TaskStateChangeRule:
    Type: "AWS::Events::Rule"
    Properties:
      Name: !Sub "${AWS::StackName}-ecs-task-state-change"
      Description: "Event to notify us of changed status of ECS Task"
      State: ENABLED
      EventPattern: !Sub 
        - |
          {
              "source": ["aws.ecs"],
              "detail-type": ["ECS Task State Change"], 
              "detail": {
                  "clusterArn": ["${Neo4jCluster.Arn}" ${replicaCluster}],
                  "taskDefinitionArn": ["${Neo4jClusterTask}" ${replicaTask}]
              }
          }
        - replicaCluster: !If [ ReplicasEnabled, !Sub ',"${Neo4jReplicas.Arn}"', ""]
          replicaTask: !If [ ReplicasEnabled, !Sub ',"${Neo4jReplicasTask}"', ""] 
      Targets:
      - Arn: !GetAtt CloudMapSyncFunction.Arn
        Id: !Sub "${AWS::StackName}-ecs-task-state-change"
  TaskStateChangeInvokeLambdaPermission: 
    Type: AWS::Lambda::Permission
    Properties: 
      FunctionName: !Ref CloudMapSyncFunction 
      Action: "lambda:InvokeFunction"
      Principal: "events.amazonaws.com"
      SourceArn: !GetAtt TaskStateChangeRule.Arn 
  TaskMonitorEventRule:
    Type: "AWS::Events::Rule"
    Properties:
      Name: !Sub "${AWS::StackName}-ecs-task-monitor"
      Description: "Event to notify us of changed status of ECS Task"
      State: ENABLED
      EventPattern: !Sub |
        {
            "source": ["aws.ecs"],
            "detail-type": ["ECS Task State Change"],
            "detail": {
                "clusterArn": ["${Neo4jCluster.Arn}"],
                "taskDefinitionArn": ["${Neo4jClusterTask}", "${Neo4jBackupTask}"],
                "stoppedReason": ["Essential container in task exited"]
            }
        }
      Targets:
      - Arn: !If [CreateSNSTopic, !Ref Neo4jSNSTopic, !Ref SNSTopicArn]
        Id: !Sub "${AWS::StackName}-ecs-task-monitor"
  TaskMonitorEventSNSPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties:
      PolicyDocument:
        Id: !Sub "${AWS::StackName}-ecs-task-monitor"
        Version: 2012-10-17
        Statement:
          ### this is copy of default TopicPolicy since its being overwritten by cloudformation
          ### and cloudwatch alarms will stop sending events to this topic
          - Sid: default-sns-policy
            Effect: Allow
            Principal:
              AWS: "*"
            Action:
              - sns:Publish
              - sns:RemovePermission
              - sns:SetTopicAttributes
              - sns:DeleteTopic
              - sns:ListSubscriptionsByTopic
              - sns:GetTopicAttributes
              - sns:Receive
              - sns:AddPermission
              - sns:Subscribe
            Resource: !If [CreateSNSTopic, !Ref Neo4jSNSTopic, !Ref SNSTopicArn]
            Condition:
              StringEquals:
                AWS:SourceOwner: !Ref AWS::AccountId
          ### When creating SNS Topic EvetRuleTarget WebConsole adding next policies
          ### automatically, in our case we need to define them
          - Sid: events-sns-permissions
            Effect: Allow
            Principal:
              Service: "events.amazonaws.com"
            Action: sns:Publish
            Resource: !If [CreateSNSTopic, !Ref Neo4jSNSTopic, !Ref SNSTopicArn]
      Topics:
        - !If [CreateSNSTopic, !Ref Neo4jSNSTopic, !Ref SNSTopicArn]
Outputs:
  Neo4jClusterECSservice:
    Value: !Ref "Neo4jClusterECSservice"
  Neo4jCluster:
    Value: !Ref "Neo4jCluster"
  Neo4jClusterTask:
    Value: !Ref "Neo4jClusterTask"
  Neo4jCoreHTTPEndpoint:
    Value: !Sub http://${Neo4jCoreSubdomain}.${CloudMapNamespaceName}:7474
  Neo4jReplicaHTTPEndpoint:
    Value: !Sub http://${Neo4jReplicasSubdomain}.${CloudMapNamespaceName}:7474
  Neo4jCoreBoltEndpoint:
    Value: !Sub bolt+routing://${Neo4jCoreSubdomain}.${CloudMapNamespaceName}:7687
  Neo4jReplicaHoltEndpoint:
    Value: !Sub bolt+routing://${Neo4jReplicasSubdomain}.${CloudMapNamespaceName}:7687